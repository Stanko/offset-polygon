{
  "version": 3,
  "sources": ["../src/offset-polygon.ts"],
  "sourcesContent": ["// TODO check these comments:\n// Assuming that polygon vertices are in clockwise order\n\ntype Vector = {\n  x: number;\n  y: number;\n};\n\ntype Vertex = {\n  x: number;\n  y: number;\n  isReflex?: boolean;\n};\n\ntype Edge = {\n  index: number;\n  inwardNormal: Vector;\n  outwardNormal: Vector;\n  vertex1: Vertex;\n  vertex2: Vertex;\n};\n\ntype OffsetEdge = {\n  vertex1: Vertex;\n  vertex2: Vertex;\n};\n\ntype Polygon = {\n  edges: Edge[];\n  offsetEdges?: OffsetEdge[];\n  maxX: number;\n  maxY: number;\n  minX: number;\n  minY: number;\n  vertices: Vertex[];\n};\n\nconst TWO_PI = Math.PI * 2;\n\n// See http://paulbourke.net/geometry/pointlineplane/\nfunction inwardEdgeNormal(vertex1: Vertex, vertex2: Vertex): Vector {\n  // Assuming that polygon vertices are in clockwise order\n  const dx = vertex2.x - vertex1.x;\n  const dy = vertex2.y - vertex1.y;\n  const edgeLength = Math.sqrt(dx * dx + dy * dy);\n\n  return {\n    x: -dy / edgeLength,\n    y: dx / edgeLength,\n  };\n}\n\nfunction outwardEdgeNormal(vertex1: Vertex, vertex2: Vertex): Vector {\n  var n = inwardEdgeNormal(vertex1, vertex2);\n\n  return {\n    x: -n.x,\n    y: -n.y,\n  };\n}\n\n// If the slope of line vertex1,vertex2 greater than the slope of vertex1,p\n// then p is on the left side of vertex1,vertex2 and the return value is > 0.\n// If p is colinear with vertex1,vertex2 then return 0, otherwise return a value < 0.\nfunction leftSide(vertex1: Vertex, vertex2: Vertex, p: Vector): number {\n  return (\n    (p.x - vertex1.x) * (vertex2.y - vertex1.y) -\n    (vertex2.x - vertex1.x) * (p.y - vertex1.y)\n  );\n}\n\nfunction isReflexVertex(vertices: Vertex[], vertexIndex: number): boolean {\n  // Assuming that polygon vertices are in clockwise order\n  var thisVertex = vertices[vertexIndex];\n  var nextVertex = vertices[(vertexIndex + 1) % vertices.length];\n  var prevVertex =\n    vertices[(vertexIndex + vertices.length - 1) % vertices.length];\n  if (leftSide(prevVertex, nextVertex, thisVertex) < 0) {\n    return true; // TBD: return true if thisVertex is inside polygon when thisVertex isn't included\n  }\n\n  return false;\n}\n\nfunction createPolygon(vertices: Vertex[]): Polygon {\n  const edges: Edge[] = [];\n  let minX = vertices.length > 0 ? vertices[0].x : undefined;\n  let minY = vertices.length > 0 ? vertices[0].y : undefined;\n  let maxX = minX;\n  let maxY = minY;\n\n  for (let i = 0; i < vertices.length; i++) {\n    vertices[i].isReflex = isReflexVertex(vertices, i);\n\n    const vertex1 = vertices[i];\n    const vertex2 = vertices[(i + 1) % vertices.length];\n\n    const outwardNormal = outwardEdgeNormal(vertex1, vertex2);\n\n    const inwardNormal = inwardEdgeNormal(vertex1, vertex2);\n\n    const edge: Edge = {\n      vertex1,\n      vertex2,\n      index: i,\n      outwardNormal,\n      inwardNormal,\n    };\n\n    edges.push(edge);\n\n    const x = vertices[i].x;\n    const y = vertices[i].y;\n    minX = Math.min(x, minX);\n    minY = Math.min(y, minY);\n    maxX = Math.max(x, maxX);\n    maxY = Math.max(y, maxY);\n  }\n\n  const polygon: Polygon = {\n    vertices,\n    edges,\n    minX,\n    minY,\n    maxX,\n    maxY,\n  };\n\n  return polygon;\n}\n\n// based on http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/, edgeA => \"line a\", edgeB => \"line b\"\n\nfunction edgesIntersection(edgeA: Edge | OffsetEdge, edgeB: Edge | OffsetEdge) {\n  const den =\n    (edgeB.vertex2.y - edgeB.vertex1.y) * (edgeA.vertex2.x - edgeA.vertex1.x) -\n    (edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex2.y - edgeA.vertex1.y);\n\n  if (den == 0) {\n    return null; // lines are parallel or coincident\n  }\n\n  const ua =\n    ((edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -\n      (edgeB.vertex2.y - edgeB.vertex1.y) *\n        (edgeA.vertex1.x - edgeB.vertex1.x)) /\n    den;\n\n  const ub =\n    ((edgeA.vertex2.x - edgeA.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -\n      (edgeA.vertex2.y - edgeA.vertex1.y) *\n        (edgeA.vertex1.x - edgeB.vertex1.x)) /\n    den;\n\n  // Edges are not intersecting but the lines defined by them are\n  const isIntersectionOutside = ua < 0 || ub < 0 || ua > 1 || ub > 1;\n\n  return {\n    x: edgeA.vertex1.x + ua * (edgeA.vertex2.x - edgeA.vertex1.x),\n    y: edgeA.vertex1.y + ua * (edgeA.vertex2.y - edgeA.vertex1.y),\n    isIntersectionOutside,\n  };\n}\n\nfunction appendArc(\n  arcSegments: number,\n  vertices: Vertex[],\n  center: Vector,\n  radius: number,\n  startVertex: Vertex,\n  endVertex: Vertex,\n  isPaddingBoundary: boolean\n) {\n  var startAngle = Math.atan2(\n    startVertex.y - center.y,\n    startVertex.x - center.x\n  );\n  var endAngle = Math.atan2(endVertex.y - center.y, endVertex.x - center.x);\n\n  if (startAngle < 0) {\n    startAngle += TWO_PI;\n  }\n\n  if (endAngle < 0) {\n    endAngle += TWO_PI;\n  }\n\n  const angle =\n    startAngle > endAngle\n      ? startAngle - endAngle\n      : startAngle + TWO_PI - endAngle;\n  const angleStep = (isPaddingBoundary ? -angle : TWO_PI - angle) / arcSegments;\n\n  vertices.push(startVertex);\n\n  for (let i = 1; i < arcSegments; ++i) {\n    const angle = startAngle + angleStep * i;\n\n    const vertex = {\n      x: center.x + Math.cos(angle) * radius,\n      y: center.y + Math.sin(angle) * radius,\n    };\n\n    vertices.push(vertex);\n  }\n\n  vertices.push(endVertex);\n}\n\nfunction createOffsetEdge(edge: Edge, dx: number, dy: number): OffsetEdge {\n  return {\n    vertex1: {\n      x: edge.vertex1.x + dx,\n      y: edge.vertex1.y + dy,\n    },\n    vertex2: {\n      x: edge.vertex2.x + dx,\n      y: edge.vertex2.y + dy,\n    },\n  };\n}\n\nfunction createMarginPolygon(\n  polygon: Polygon,\n  offset: number,\n  arcSegments: number\n): Polygon {\n  const offsetEdges: OffsetEdge[] = [];\n\n  for (let i = 0; i < polygon.edges.length; i++) {\n    const edge = polygon.edges[i];\n    const dx = edge.outwardNormal.x * offset;\n    const dy = edge.outwardNormal.y * offset;\n    offsetEdges.push(createOffsetEdge(edge, dx, dy));\n  }\n\n  const vertices: Vertex[] = [];\n\n  for (let i = 0; i < offsetEdges.length; i++) {\n    const thisEdge = offsetEdges[i];\n    const prevEdge =\n      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];\n    const vertex = edgesIntersection(prevEdge, thisEdge);\n\n    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {\n      vertices.push(vertex);\n    } else {\n      const arcCenter = polygon.edges[i].vertex1;\n\n      appendArc(\n        arcSegments,\n        vertices,\n        arcCenter,\n        offset,\n        prevEdge.vertex2,\n        thisEdge.vertex1,\n        false\n      );\n    }\n  }\n\n  const marginPolygon = createPolygon(vertices);\n\n  marginPolygon.offsetEdges = offsetEdges;\n\n  return marginPolygon;\n}\n\nfunction createPaddingPolygon(\n  polygon: Polygon,\n  offset: number,\n  arcSegments: number\n): Polygon {\n  const offsetEdges: OffsetEdge[] = [];\n\n  for (let i = 0; i < polygon.edges.length; i++) {\n    const edge = polygon.edges[i];\n    const dx = edge.inwardNormal.x * offset;\n    const dy = edge.inwardNormal.y * offset;\n    offsetEdges.push(createOffsetEdge(edge, dx, dy));\n  }\n\n  const vertices: Vertex[] = [];\n\n  for (let i = 0; i < offsetEdges.length; i++) {\n    const thisEdge = offsetEdges[i];\n    const prevEdge =\n      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];\n    const vertex = edgesIntersection(prevEdge, thisEdge);\n    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {\n      vertices.push(vertex);\n    } else {\n      const arcCenter = polygon.edges[i].vertex1;\n\n      appendArc(\n        arcSegments,\n        vertices,\n        arcCenter,\n        offset,\n        prevEdge.vertex2,\n        thisEdge.vertex1,\n        true\n      );\n    }\n  }\n\n  const paddingPolygon = createPolygon(vertices);\n\n  paddingPolygon.offsetEdges = offsetEdges;\n\n  return paddingPolygon;\n}\n\nexport default function offsetPolygon(\n  vertices: Vector[],\n  offset: number,\n  arcSegments: number = 0\n): Vector[] {\n  const polygon = createPolygon(vertices);\n\n  if (offset > 0) {\n    return createMarginPolygon(polygon, offset, arcSegments).vertices;\n  } else {\n    return createPaddingPolygon(polygon, -offset, arcSegments).vertices;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
