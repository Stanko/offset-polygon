import './Demo.svelte.css.proxy.js';
/* demo/Demo.svelte generated by Svelte v3.44.0 */
import {
	SvelteComponent,
	append,
	attr,
	binding_callbacks,
	check_outros,
	create_component,
	destroy_component,
	destroy_each,
	detach,
	element,
	empty,
	group_outros,
	init as init_1,
	insert,
	mount_component,
	safe_not_equal,
	space,
	svg_element,
	transition_in,
	transition_out
} from "../snowpack/pkg/svelte/internal.js";

import { onMount } from '../snowpack/pkg/svelte.js';
import Draggable from './Draggable.svelte.js';
import Control from './Control.svelte.js';
import generatePolygon from './generate-polygon.js';
import isMobileDevice from './is-mobile-device.js';
import offsetPolygon from '../src/offset-polygon.js';

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[21] = list[i];
	child_ctx[23] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[21] = list[i];
	return child_ctx;
}

// (123:2) {#if size}
function create_if_block(ctx) {
	let path;
	let path_d_value;
	let if_block0_anchor;
	let if_block1_anchor;
	let each0_anchor;
	let each1_anchor;
	let current;
	let if_block0 = /*padding*/ ctx[5] > 0 && create_if_block_2(ctx);
	let if_block1 = /*margin*/ ctx[7] > 0 && create_if_block_1(ctx);
	let each_value_1 = /*p*/ ctx[2];
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	let each_value = /*p*/ ctx[2];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			path = svg_element("path");
			if (if_block0) if_block0.c();
			if_block0_anchor = empty();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			each0_anchor = empty();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each1_anchor = empty();
			attr(path, "fill", "none");
			attr(path, "d", path_d_value = "M " + /*p*/ ctx[2].map(func).join(' L ') + " Z");
			attr(path, "stroke", "silver");
		},
		m(target, anchor) {
			insert(target, path, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert(target, if_block0_anchor, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(target, anchor);
			}

			insert(target, each0_anchor, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty & /*p*/ 4 && path_d_value !== (path_d_value = "M " + /*p*/ ctx[2].map(func).join(' L ') + " Z")) {
				attr(path, "d", path_d_value);
			}

			if (/*padding*/ ctx[5] > 0) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					if_block0.m(if_block0_anchor.parentNode, if_block0_anchor);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*margin*/ ctx[7] > 0) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty & /*p*/ 4) {
				each_value_1 = /*p*/ ctx[2];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(each0_anchor.parentNode, each0_anchor);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;
			}

			if (dirty & /*p, onDrag*/ 516) {
				each_value = /*p*/ ctx[2];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each1_anchor.parentNode, each1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(path);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(if_block0_anchor);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
			destroy_each(each_blocks_1, detaching);
			if (detaching) detach(each0_anchor);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each1_anchor);
		}
	};
}

// (130:4) {#if padding > 0}
function create_if_block_2(ctx) {
	let path;
	let path_d_value;

	return {
		c() {
			path = svg_element("path");
			attr(path, "fill", "none");
			attr(path, "d", path_d_value = "M " + /*p1*/ ctx[3].map(func_1).join(' L ') + " Z");
			attr(path, "stroke", "#e74c3c");
		},
		m(target, anchor) {
			insert(target, path, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*p1*/ 8 && path_d_value !== (path_d_value = "M " + /*p1*/ ctx[3].map(func_1).join(' L ') + " Z")) {
				attr(path, "d", path_d_value);
			}
		},
		d(detaching) {
			if (detaching) detach(path);
		}
	};
}

// (138:4) {#if margin > 0}
function create_if_block_1(ctx) {
	let path;
	let path_d_value;

	return {
		c() {
			path = svg_element("path");
			attr(path, "fill", "none");
			attr(path, "d", path_d_value = "M " + /*p2*/ ctx[4].map(func_2).join(' L ') + " Z");
			attr(path, "stroke", "#3498db");
		},
		m(target, anchor) {
			insert(target, path, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*p2*/ 16 && path_d_value !== (path_d_value = "M " + /*p2*/ ctx[4].map(func_2).join(' L ') + " Z")) {
				attr(path, "d", path_d_value);
			}
		},
		d(detaching) {
			if (detaching) detach(path);
		}
	};
}

// (146:4) {#each p as point}
function create_each_block_1(ctx) {
	let circle;
	let circle_cx_value;
	let circle_cy_value;

	return {
		c() {
			circle = svg_element("circle");
			attr(circle, "fill", "silver");
			attr(circle, "r", "3");
			attr(circle, "cx", circle_cx_value = /*point*/ ctx[21].x);
			attr(circle, "cy", circle_cy_value = /*point*/ ctx[21].y);
		},
		m(target, anchor) {
			insert(target, circle, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*p*/ 4 && circle_cx_value !== (circle_cx_value = /*point*/ ctx[21].x)) {
				attr(circle, "cx", circle_cx_value);
			}

			if (dirty & /*p*/ 4 && circle_cy_value !== (circle_cy_value = /*point*/ ctx[21].y)) {
				attr(circle, "cy", circle_cy_value);
			}
		},
		d(detaching) {
			if (detaching) detach(circle);
		}
	};
}

// (150:4) {#each p as point, index}
function create_each_block(ctx) {
	let draggable;
	let current;

	function func_3(...args) {
		return /*func_3*/ ctx[14](/*index*/ ctx[23], ...args);
	}

	draggable = new Draggable({
			props: {
				left: /*point*/ ctx[21].x,
				top: /*point*/ ctx[21].y,
				onChange: func_3
			}
		});

	return {
		c() {
			create_component(draggable.$$.fragment);
		},
		m(target, anchor) {
			mount_component(draggable, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const draggable_changes = {};
			if (dirty & /*p*/ 4) draggable_changes.left = /*point*/ ctx[21].x;
			if (dirty & /*p*/ 4) draggable_changes.top = /*point*/ ctx[21].y;
			draggable.$set(draggable_changes);
		},
		i(local) {
			if (current) return;
			transition_in(draggable.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(draggable.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(draggable, detaching);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let h2;
	let t1;
	let control0;
	let t2;
	let control1;
	let t3;
	let control2;
	let t4;
	let control3;
	let t5;
	let svg;
	let svg_viewBox_value;
	let t6;
	let p_1;
	let current;

	control0 = new Control({
			props: {
				max: "100",
				label: "Padding",
				value: /*padding*/ ctx[5],
				name: "padding",
				onChange: /*onPaddingChange*/ ctx[10]
			}
		});

	control1 = new Control({
			props: {
				label: "Padding arc segments",
				value: /*paddingArcSegments*/ ctx[6],
				name: "padding-arc-segments",
				onChange: /*onPaddingArcSegmentsChange*/ ctx[11]
			}
		});

	control2 = new Control({
			props: {
				max: "100",
				label: "Margin",
				value: /*margin*/ ctx[7],
				name: "margin",
				onChange: /*onMarginChange*/ ctx[12]
			}
		});

	control3 = new Control({
			props: {
				label: "Margin arc segments",
				value: /*marginArcSegments*/ ctx[8],
				name: "margin-arc-segments",
				onChange: /*onMarginArcSegmentsChange*/ ctx[13]
			}
		});

	let if_block = /*size*/ ctx[0] && create_if_block(ctx);

	return {
		c() {
			div = element("div");
			h2 = element("h2");
			h2.textContent = "Interactive demo";
			t1 = space();
			create_component(control0.$$.fragment);
			t2 = space();
			create_component(control1.$$.fragment);
			t3 = space();
			create_component(control2.$$.fragment);
			t4 = space();
			create_component(control3.$$.fragment);
			t5 = space();
			svg = svg_element("svg");
			if (if_block) if_block.c();
			t6 = space();
			p_1 = element("p");
			p_1.textContent = "Try dragging the vertices.";
			attr(div, "class", "content");
			attr(svg, "viewBox", svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0]);
			attr(p_1, "class", "note svelte-zlj7hl");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, h2);
			append(div, t1);
			mount_component(control0, div, null);
			append(div, t2);
			mount_component(control1, div, null);
			append(div, t3);
			mount_component(control2, div, null);
			append(div, t4);
			mount_component(control3, div, null);
			insert(target, t5, anchor);
			insert(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
			/*svg_binding*/ ctx[15](svg);
			insert(target, t6, anchor);
			insert(target, p_1, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const control0_changes = {};
			if (dirty & /*padding*/ 32) control0_changes.value = /*padding*/ ctx[5];
			control0.$set(control0_changes);
			const control1_changes = {};
			if (dirty & /*paddingArcSegments*/ 64) control1_changes.value = /*paddingArcSegments*/ ctx[6];
			control1.$set(control1_changes);
			const control2_changes = {};
			if (dirty & /*margin*/ 128) control2_changes.value = /*margin*/ ctx[7];
			control2.$set(control2_changes);
			const control3_changes = {};
			if (dirty & /*marginArcSegments*/ 256) control3_changes.value = /*marginArcSegments*/ ctx[8];
			control3.$set(control3_changes);

			if (/*size*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*size*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(svg, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty & /*size*/ 1 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*size*/ ctx[0] + " " + /*size*/ ctx[0])) {
				attr(svg, "viewBox", svg_viewBox_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(control0.$$.fragment, local);
			transition_in(control1.$$.fragment, local);
			transition_in(control2.$$.fragment, local);
			transition_in(control3.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(control0.$$.fragment, local);
			transition_out(control1.$$.fragment, local);
			transition_out(control2.$$.fragment, local);
			transition_out(control3.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(control0);
			destroy_component(control1);
			destroy_component(control2);
			destroy_component(control3);
			if (detaching) detach(t5);
			if (detaching) detach(svg);
			if (if_block) if_block.d();
			/*svg_binding*/ ctx[15](null);
			if (detaching) detach(t6);
			if (detaching) detach(p_1);
		}
	};
}

const func = p => `${p.x} ${p.y}`;
const func_1 = p => `${p.x} ${p.y}`;
const func_2 = p => `${p.x} ${p.y}`;

function instance($$self, $$props, $$invalidate) {
	let size = 0;
	let r;
	let center;
	let svgElement;
	let p;
	let p1;
	let p2;
	let padding = 15;
	let paddingArcSegments = 5;
	let margin = 15;
	let marginArcSegments = 5;

	const init = () => {
		$$invalidate(0, size = svgElement.clientWidth);
		r = size * 0.35;
		center = { x: size / 2, y: size / 2 };
		$$invalidate(2, p = generatePolygon(6, r, center));
		$$invalidate(3, p1 = offsetPolygon(p, -padding, paddingArcSegments));
		$$invalidate(4, p2 = offsetPolygon(p, margin, marginArcSegments));
	};

	let windowHeight = window.innerHeight;
	let windowWidth = window.innerWidth;

	onMount(() => {
		init();
		let resizeTimeout;

		function onResize() {
			if (!isMobileDevice || windowHeight !== window.innerHeight && windowWidth !== window.innerWidth) {
				clearTimeout(resizeTimeout);
				resizeTimeout = setTimeout(init, 250);
			}

			windowHeight = window.innerHeight;
			windowWidth = window.innerWidth;
		}

		window.addEventListener('resize', onResize);

		return () => {
			clearTimeout(resizeTimeout);
			window.removeEventListener('resize', onResize);
		};
	});

	let onDrag = (e, index) => {
		$$invalidate(2, p[index].x += e.movementX, p);
		$$invalidate(2, p[index].y += e.movementY, p);
		$$invalidate(3, p1 = offsetPolygon(p, -padding, paddingArcSegments));
		$$invalidate(4, p2 = offsetPolygon(p, margin, marginArcSegments));
	};

	const onPaddingChange = e => {
		$$invalidate(5, padding = e.target.value);
		$$invalidate(3, p1 = offsetPolygon(p, -padding, paddingArcSegments));
	};

	const onPaddingArcSegmentsChange = e => {
		$$invalidate(6, paddingArcSegments = e.target.value);
		$$invalidate(3, p1 = offsetPolygon(p, -padding, paddingArcSegments));
	};

	const onMarginChange = e => {
		$$invalidate(7, margin = e.target.value);
		$$invalidate(4, p2 = offsetPolygon(p, margin, marginArcSegments));
	};

	const onMarginArcSegmentsChange = e => {
		$$invalidate(8, marginArcSegments = e.target.value);
		$$invalidate(4, p2 = offsetPolygon(p, margin, marginArcSegments));
	};

	const func_3 = (index, e) => onDrag(e, index);

	function svg_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			svgElement = $$value;
			$$invalidate(1, svgElement);
		});
	}

	return [
		size,
		svgElement,
		p,
		p1,
		p2,
		padding,
		paddingArcSegments,
		margin,
		marginArcSegments,
		onDrag,
		onPaddingChange,
		onPaddingArcSegmentsChange,
		onMarginChange,
		onMarginArcSegmentsChange,
		func_3,
		svg_binding
	];
}

class Demo extends SvelteComponent {
	constructor(options) {
		super();
		init_1(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default Demo;